class Solution(object):
    def isHappy(self, n):

        def get_next(num):
            total = 0
            while num > 0:
                digit = num % 10
                total += digit * digit
                num //= 10
            return total
        
        slow = n
        fast = get_next(n)
        
        while fast != 1 and slow != fast:
            slow = get_next(slow)
            fast = get_next(get_next(fast))
        
        return fast == 1
    
n = 19
sol = Solution()
print(sol.isHappy(n))

# Time Complexity
# O(log n) per step (number of digits in n)

# Usually less than 100 steps in worst case

# So overall: O(log n)

# Space Complexity
# O(1) using cycle detection (Floyd’s algorithm, no extra data structures)

# | Element                | Description                                                                                |
# | ---------------------- | ------------------------------------------------------------------------------------------ |
# | **Algorithm**          | **Floyd's Cycle Detection Algorithm** (also called Tortoise & Hare)                        |
# | **Technique**          | **Cycle Detection** in a sequence of numbers generated by sum of squares                   |
# | **Approach**           | Use two pointers (`slow` and `fast`) to detect cycles without extra space                  |
# | **Time Complexity**    | `O(log n)` per step, total steps are bounded → overall **O(log n)**                        |
# | **Space Complexity**   | **O(1)** (constant space, no extra data structures)                                        |
# | **Alternate Approach** | Use a `HashSet` to detect repeating numbers → needs **O(log n)** time & **O(log n)** space |